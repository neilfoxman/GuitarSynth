# https://pythontic.com/visualization/signals/fouriertransform_fft
import numpy as np
import matplotlib.pyplot as plt
#from scipy.fftpack import rfft, fftfreq
import math

fs = 44100.0
Ts = 1/fs

t0 = 0
tf = 0.1

f1 = 440.0
f2 = 261.6

t = np.arange(t0, tf, Ts)

sig1 = np.sin(2*np.pi*f1*t)
sig2 = np.sin(2*np.pi*f2*t)

figure, axis = plt.subplots(4,1)
plt.subplots_adjust(hspace=1)

axis[0].set_title('First sin wave')
axis[0].plot(t,sig1)
axis[0].set_xlabel('Time')
axis[0].set_ylabel('Amplitude')

axis[1].set_title('Second sin wave')
axis[1].plot(t,sig2)
axis[1].set_xlabel('Time')
axis[1].set_ylabel('Amplitude')

sig3 = sig1 + sig2

axis[2].set_title('Sin wave with multiple frequencies')
axis[2].plot(t,sig3)
axis[2].set_xlabel('Time')
axis[2].set_ylabel('Amplitude')



# trans1 = np.fft.rfft(sig3)#/len(sig3) # Normalize (
# f1 = np.fft.fftfreq(len(sig3), Ts)
# #trans1 = rfft(sig3)#/len(sig3) # Normalize (
# #f1 = fftfreq(len(sig3), Ts)
# print("Input signal is ", len(sig3), " long")
# print("Output of fft() is ", len(trans1), " long")
# print(len(f1), " frequency bins created")
# print("fft result is of type ", trans1.dtype)





def frequencyToMidiNote(f):
    if(f <=0):
        return 0
    else:
        return 12.0*math.log(float(f)/27.5,2)+21

def midiNoteToFrequency(midiNote):
    return 27.5*2.0**((float(midiNote)-21.0)/12.0)

class Note:
    def __init__(self, midiNum):
        self.midiNum = float(midiNum)
        self.frequency = midiNoteToFrequency(self.midiNum)
        self.isPlaying = False
        
    
def mapFrequenciesToNotes(fArray):
    # Create list of notes
    noteList = []
    
    # Assign each frequency a midi note and add it to the list
    for f in farray:
        midiNum = frequencyToMidiNote(f)
        noteList.append(int(round(midiNum)))
        
    # By now you should have a list of notes the same size as the farray
    # Convert the list into an array
    noteArray = np.array(noteList)
    return noteArray

# Create an array of notes where the index corresponds to the midi number
def generateMasterNoteArray(noteMap):
    masterNoteList = []

    # Find maximum note number used (last entry in noteMap)
    maxNote = noteMap[len(noteMap) - 1]
    
    # Create an array of note objects up to and including that number
    for noteNumber in range(maxNote + 1):
        masterNoteList.append(Note(noteNumber))
    
    # Convert to array
    masterNoteArr = np.array(masterNoteList)

    
    # Diagnostics - The bins generated by fft are spaced out in a linear scale while
    # acoustic notes are spaced out on a logarithmic scale (see conversion functions).
    # This means that the lower midi notes may not have corresponding
    # frequency bins after fft().  This section detects the lowest sequential frequency.

    # Count down from highest frequency
    for idx in reversed(range(len(noteMap))):
        # If we have counted down past zero than no notes are skipped
        if(idx-1 < 0):
            print("All midi notes can be played!")
        
        # If the note lower than the inspected one is not exactly one lower,
        elif((noteMap[idx-1] != noteMap[idx]) and
             (noteMap[idx-1] != noteMap[idx] - 1)):
            # Then we found our lower bound of sequential notes
            
            print(noteMap[idx-1], " is not sequential with ", noteMap[idx])
            print("Lowest sequential playable note is ", noteMap[idx])
            break
        
    
    notesUsed = []
    lastNoteAdded = -1
    
    return masterNoteArr

def generateFrequencyArray(signalLength, samplePeriod):
    # Fng frequencies that would be used given a signal sample length and sample period
    farray_all = np.fft.fftfreq(signalLength, samplePeriod)
    
    # Create dummy signal and runn fft to get appropriate length of transformation
    dummySig = np.zeros(signalLength)
    dummyTransformed = np.fft.rfft(dummySig)
    
    # Exclude redundant frequencies due to discrete transform
    usableBins = range(len(dummyTransformed) - 1) # last bin is negative frequency
    farray = farray_all[usableBins]
    
    # Debug
    print("Dummy Input signal is ", len(dummySig), " long")
    print("Dummy Output of fft() is ", len(dummyTransformed), " long")
    print(len(farray), " frequency bins created by fftfreq")
    print("Asserting that there are ", len(usableBins), " usable bins")
    
    return farray, usableBins

def runFFT(signal, rangeOfUsableBins):
    # Transform array into frequency domain
    transformed_all = np.fft.rfft(signal)#/len(sig3) # Normalize (
    
    # Exclude redundant frequencies due to discrete transform
    transformed = abs(transformed_all[rangeOfUsableBins])
    
    # Debug
    print("Input signal is ", len(signal), " long")
    print("Output of fft() is ", len(transformed_all), " long")
    print("Usable fft() output is ", len(transformed), " long")
    print("fft result is of type ", transformed.dtype)

    return transformed

def detectNote(transarr, detectionThreshold, frequencyToNoteMap, masterNoteArray):
    # Find spectrum values above threshold
    idx = 0
    while idx < len(transarr):
        # If the spectrum amplitude is higher than threshold
        if transarr[idx] > detectionThreshold:
            # Find corresponding midi note number
            midiNoteNum = frequencyToNoteMap[idx]
            
            # Set note to playing in the master note array
            masterNoteArray[midiNoteNum].isPlaying = True
            
            # Debug
            print("Playing note: ", midiNoteNum)
            
        idx += 1
    return masterNoteArray




### This code should be run beforehand to set up the analysis



# Generate array of frequencies corresponding to the bins when fft runs
# Do this in the beginning so it doesn't have to run each cycle
signalLength = len(sig3)
farray, usableBins = generateFrequencyArray(signalLength, Ts)

# Assign each frequency to a Midi Note
noteMap = mapFrequenciesToNotes(farray)

# Create an array of all the playable notes
masterNoteArray = generateMasterNoteArray(noteMap)

# Set note detection threshold
# Output of fft() is scaled by len(sig), compensate for that here
# One could also normalize the fft output, but that takes more time in the loop
noteDetectionThreshold = 0.5*len(usableBins)



### This stuff should run really fast in the loop

# Run fft
transformed = runFFT(sig3,usableBins)

# Run note detection
detectNote(transformed, noteDetectionThreshold, noteMap, masterNoteArray)



### End of loop


axis[3].set_title('Fourier transform')
axis[3].plot(farray,transformed)
axis[3].set_xlabel('Frequency')
axis[3].set_ylabel('Amplitude')

plt.show()
